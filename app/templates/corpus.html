{% extends 'base.html' %}
{% block navbar %}
<li class="active"><a href="/main">Home</a></li>
{% endblock%}

{% block extrastyle %}
<link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.datatables.net/1.10.24/css/dataTables.bootstrap.min.css" rel="stylesheet">
<link href="https://cdn.datatables.net/responsive/2.2.7/css/responsive.bootstrap.min.css" rel="stylesheet">

{% endblock %}
{% block content %}

<main style="margin-top: 200px;" id="main">

    <!-- ======= Breadcrumbs ======= -->
    <section class="breadcrumbs">
      <div class="container">

        <div class="d-flex justify-content-between align-items-center">
          <h2>Frequent Tokens</h2>
        </div>
        <div class="faq-list">
          <button class="nice-button" onclick="location.href='/texts'">Back<i style='color:white;'class='icofont-long-arrow-left'></i></button>
          
          <button class="nice-button" onclick="location.href='/export-texts'">Next<i style='color:white;'class='icofont-long-arrow-right'></i></button>
         </div>  
         <br>
         <p>In this section you can add lemma, pos, and entity labels to frequent tokens. You will significantly reduce the amount
          of time needed to annotate your corpus. You can also mark tokens as stop words. They will have a
          token.is_stop attribute.</p>
      </div>
    </section><!-- End Breadcrumbs -->

    <!-- ======= Counts Section ======= -->
<section id="counts" class="counts">
    <div class="container">

      <div class="row counters">
        {% if stats %}
        <div class="col-lg-3 col-6 text-center">
          {% if stats.texts %}
          <span data-toggle="counter-up">{{ stats.texts }}</span>
          <p>Texts</p>
          {% endif %}
        </div>

        <div class="col-lg-3 col-6 text-center">
          {% if stats.tokens %}
          <span data-toggle="counter-up">{{ stats.tokens }}</span>
          <p>Tokens</p>
          {% endif %}
        </div>
       
        {% if stats.sents %}
        <div class="col-lg-3 col-6 text-center">
          <span data-toggle="counter-up">{{ stats.sents }}</span>
          <p>Sentences</p>
        </div>
        {% endif %}

        {% if stats.sents %}
        <div class="col-lg-3 col-6 text-center">
          <span data-toggle="counter-up">{{ stats.ents }}</span>
          <p>Entities</p>
        </div>
        {% endif %}
        
        {% endif %}

      </div>
    </div>
  </section><!-- End Counts Section -->
  <section id="testimonials" class="testimonials section-bg">
    <div class="container">
      <div id='chart'><!-- Plotly chart will be drawn inside this DIV --></div>
      
      <table id="tokens" class="table table-striped table-bordered dt-responsive nowrap" style="width:100%"></table>
      </div>
  </section>





{% endblock %}

{% block extrajs %}
<script src="https://cdn.datatables.net/1.10.23/js/jquery.dataTables.min.js"></script>
<script src="https://cdn.datatables.net/1.10.23/js/dataTables.bootstrap4.min.js"></script>
<script src='https://cdn.plot.ly/plotly-latest.min.js'></script>

<script>
    $('#header').addClass('header-scrolled')
    let tokens = {{ tokens_json|safe }};
    let data = []; 
    for (const token of tokens) {
      data.push(new Array(token.count, token.text, token.lemma_,token.pos_,token.is_stop));
    }
    $('#tokens').DataTable( {
      data: data,
      pageLength: 50,
      order: [[ 0, "desc" ]],
      columns: [
            { title: "Count" },
            //{ title: "Before" },
            { title: "Text" },
            //{ title: "After" },
            { title: "Lemma",
            "render": function ( row, type, val, meta ) {
              return "<p contenteditable='true' onkeyup='update_lemma(this,"+ '"'+ val[1]+ '"' + ");'>" +row +"</p>"; }
            },
            { title: "Part of Speech",
            "render": function ( row, type, val, meta ) {
              return "<p contenteditable='true' onkeyup='update_pos(this,"+ '"'+ val[1]+ '"' + ");'>" +row +"</p>"; }
            },
            { title: "Stop Word",
            "render": function ( row, type, val, meta ) {
              return "<p onclick='edit_stop(this,"+ '"'+ val[1]+ '"' + ");'>" +row +"</p>"; }
            }
        ]
  } );
</script>
<script>
  function edit_stop(e, val) { 

    if (e.innerHTML == '☐'){
      e.innerHTML="☑";
      $.get( "add_stopword?word="+val, function( data ) {
        // success
      });
     
    }
    else {
      e.innerHTML = "☐";
      $.get( "delete_stopword?word="+val, function( data ) {
        // success
      });
    }
    
  };

  function update_lemma(e, val){
    $.get( "update_lemma?word="+val+'&lemma='+ e.innerHTML, function( data ) {
      // success
    });
  };

  function update_pos(e, val){
    $.get( "update_pos?word="+val+'&pos='+ e.innerHTML, function( data ) {
      // success
    });
  };
</script>
<script>

// Plotly Chart Section 
  let x_data = [];
  let y_data = [];
  let hover_data = [];
  for (const token of tokens) {
    x_data.push(token.count);
    y_data.push(token.remain);
    hover_data.push(token.text + ':'+ token.count);
  }

// mousewheel or two-finger scroll zooms the plot

var trace1 = {
  x: x_data,
  y: y_data,
  text: hover_data,
  type: 'line'
};

var data1 = [trace1];

var layout = {
  title: {
    text:'Correlation of Frequent Tokens to Total Corpus Annotation',
    font: {
      family: 'Poppins,  sans-serif',
      size: 18
    },
    xref: 'paper',
    x: 0.05,
  },
  xaxis: {
    title: {
      text: 'Number of Frequent Tokens',
      font: {
        family: 'Open Sans, sans-serif',
        size: 14,
        color: '#7f7f7f'
      }
    },
  },
  yaxis: {
    title: {
      text: 'Total Tokens Annotated',
      font: {
        family: 'Open Sans, sans-serif',
        size: 14,
        color: '#7f7f7f'
      }
    }
  },
  paper_bgcolor: '#f9f8ff',
  plot_bgcolor: '#f9f8ff'
};

Plotly.newPlot('chart', data1, layout, {scrollZoom: true,displaylogo: false});

</script>
{% endblock %}

<!-- TODO 
add filters to exclude common stop word-type tokens 
ability to mark token as a stop word and update stop words.py
ability to click on cell in dataframe and update values, save those in lookups -->